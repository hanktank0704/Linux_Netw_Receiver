  

7.19 미팅

---

- 지난 스터디 메모
    
    황재훈 - NAPI 발표
    
    GRO는 포인터만 옮기게 됨.
    
    GFP - get free page, interrupt vector 공부 하기
    
    top half bottom half가 정확하게 뭔지?
    
    __napi_schedule 에서 rasie~ 는 irq를 끄고 하는것이라는 의미
    
    napi 쓰레드가 인터럽터블이 아니면 비트만 셋팅하고 넘어감. 그게 아니면 직접 건드려서 napi가 되도록 하는 것임.
    
    atomic operation - 병렬 처리 과정에서 동시성을 보장하기 위해 명령어 단에서 지원하는 것. 자체적인 큐가 있어서 명령어의 실행이 순차적으로 되게 만들게 됨.
    
    guarantee → 학술적으로는 100% 보장할 떄 말하는 것임. 믿고 써도 됨.
    
    XDP → 기존에는 커널을 컴파일을 띄워야함
    
    추가적으로 로직을 추가해서 프로파일링이 가능하게 만들어줌
    
    드라이버 단에 들어있는 trace point ⇒ XDP
    
    시작지점, 끝지점을 찍어보는것
    
    만들고 싶은 로직을 넣을 수도 있음
    
    매번 컴파일을 안하고도 라이브 상태에서 삽입할 수 있음
    
    AF_XDP 소켓 → 커널을 거치지 않고 바로 user space으로 꽂아줄 수 있음.
    
    커널 코드 상에 어딘가에 이벤트, 혹은 코드를 지날 떄 임의의 코드를 실행시킬 수 있게 만들어줌.
    
    XDP는 안따라가는 걸로.
    
      
    
    전이중 통신을 하게 될 수 있으므로 Tx/Rx가 동시에 가능함.
    
    디스크립터가 링구조임.
    
    재활용→ 한바퀴 돌았을 떄 클린을 하게 됨. → 링버퍼로 사용할 수 있도록
    
    napi_poll budget → 최종적으로 가져올 수 있는 최대 용량
    
    디스크립터 공간, 메모리 공간
    
    디스크립터는 재활용이 가능한데, 메모리 공간은 dma 필드의 주소를 통해 재할당하면 됨.
    
    따라서 디스크립터는 init할때 dma하게 됨.
    
    NIC head, tail register → tail은 내가 다음에 사용할 index값.
    
      
    
    perf→ 주기적으로 어느 함수를 실행하고 있는지 체크하게 됨.
    
    napi_gro_receive()
    

  

### 주요 토픽

---

- iperf : 관련자료 및 유튜브 수신하였고, 차주까지 공부할 예정.  
    다양한 옵션을 가지고 mac native 환경에서 loopback의 최대 대역폭을 구하고 있는데, Parallel 옵션을 사용하여 기존대비 2배정도의 대역폭을 확인 할 수 있었음. 계속하여 구글링과 iperf를 통해 최대 대역폭이 정확하게 얼마인지 확보하고, 이를 바탕으로 parallel 옵션이 빠졌을 때 네트워크 서브 시스템의 오버헤드인지, iperf 소스 코드의 오버헤드인지 확인할 수 있는 실험을 설계하고자 함.  
    

  

- GRO : napi 과정과 유기적으로 연결되어 있었고, tcp/udp, ipv4/ipv6에 따라서 callback 함수가 실행되는 것을 확인할 수 있었음. 모든 과정은 앞서 정리한 napi 아래의 napi_gro_receive() 함수 내부에 정리되어 있으며, 주요 경로라고 생각한 ipv4 - tcp를 기준으로 정리함. 소켓의 frag_list에다가 복사하는 부분과, 각 헤더들을 XOR을 통해 same flow인지 확인하는 부분을 볼 수 있었고, 이를 굿노트로 도식화 함.  
      
      
      
    

스터디 내용

---

연구실 옵시디언으로 이주 가능성….