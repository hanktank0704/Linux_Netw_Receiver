지난 스터디 주요 내용

---

- GRO 부분 다시 정리 및 개선점 고민해보기
- Bottom up Path 백서 옵시디언으로 이주 고려
- GRO 중 L3, L4 부분에서 분기하는 지점 확인 및 정리 하기
- Iperf3 개선 ppt 살펴볼 것

  

### 주요 토픽

---

- GRO  
      
      
    → ipv6 및 udp등 가능한 모든 옵션 분기 확인 완료. skb_gro_receive() 함수로 모두 수렴하는 것까지 확인하였고, 이렇게 나뉘어진 이유로는 각 헤더별 오프셋이 다르고 이를 체크하는 것까지 확인함.  
      
      
      
    → 여기서 각 패킷 타입별로 상위 스택으로 올라기는 entry point를 확인할 수 있었음. 어떻게 매핑이 되고 어떤 함수가 실행되는지 찾을 수 있도록 정리함. 현재 GRO에 집중하고 있는 관계로 GRO가 끝난다면 이어서 정리해 나갈 예정.  
      
      
      
    → sk_buff가 napi 단에서 어떻게 동작하는지 아직 이해가 부족하다고 생각하여 앞부분은 더 공부하였었고, 실제 sk_buff에서 가르킬 data 영역을 할당받는 부분을 추가로 발견하였음. 따라서 rx_ring buf 에서 memcpy로 가져오는 부분이 존재해야 함을 알 수 있었음.  
    

  

  

  

스터디 내용 메모

---

- 황재훈 - dev_gro_receive()

초록색으로 색칠되어있는부분을 비교하여 같은 flow인지 확인하게 됨.

xdp에서 pass가 되는 경우를 자세하게 살펴볼 것.

저 포인터가 가르키고 있는 공간에는 어떤 데이터를 가지고 있는가?

아마 rx_buf를 포인팅 하고 있을텐데 이걸 정확하게 할 것.

raw data를 직접 DMA를 통해 메인 메모리에 저장함.

skb를 비교할 때 메타데이터를 비교할려면 미리 셋팅이 되어있어야 함. 이거는 혹시 오버헤드가 있는지 확인해볼 것.

offloading → stand-alone한 작업 위주로.

ack nr이 같은지 확인한다. → 만약 client가 host에게 무언가를 보냈을 경우 state의 변화가 있을 수 있으므로 합치지 않게 됨.

tcp에서인지 ip에서인지 문제를 확인해 보자 더 많은 것을 앞으로 해서 오버헤드를 조금이라도 줄일 수 있을 것이다.

커널 로그 찍는 법 B2, A2 서버를 확인해 보면 좋을 듯.

글로써 정리하는 것을 연습할 것.

gro_normal의 의미를 확인할 것.

함수들 간의 기능 비교 해볼 것.

Rps, rfs dev까지 왔을 떄 어디로 넣어주는가를 확인할 것.